#!/usr/bin/env python3
"""Generate shared type definitions for frontend (TypeScript) and backend (Python)."""

from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Any

ROOT = Path(__file__).resolve().parent.parent
SCHEMA_DIR = ROOT / "shared" / "schema"
TS_TARGET = ROOT / "web" / "src" / "types" / "shared.ts"
PY_TARGET = ROOT / "server" / "shared_types.py"

TS_HEADER = """/* eslint-disable */
// AUTO-GENERATED BY scripts/generate_shared_types.py
// Do not edit this file manually.
"""

PY_HEADER = """\"\"\"AUTO-GENERATED FILE. DO NOT EDIT.

Generated by scripts/generate_shared_types.py
\"\"\"
"""


TS_PRIMITIVES: dict[str, str] = {
    "string": "string",
    "boolean": "boolean",
    "number": "number",
    "integer": "number",
    "null": "null",
}

PY_PRIMITIVES: dict[str, str] = {
    "string": "str",
    "boolean": "bool",
    "number": "float",
    "integer": "int",
    "null": "None",
}


def _pascal_case(value: str) -> str:
    parts = re.split(r"[^a-zA-Z0-9]", value)
    return "".join(part.capitalize() for part in parts if part)


def _nested_typeddict_name(root: str, path: list[str]) -> str:
    suffix = "".join(_pascal_case(segment) for segment in path)
    return f"{root}{suffix}"


def load_schemas() -> list[dict[str, Any]]:
    schemas: list[dict[str, Any]] = []
    if not SCHEMA_DIR.exists():
        return schemas
    for path in sorted(SCHEMA_DIR.glob("*.json")):
        with path.open("r", encoding="utf-8") as fh:
            schemas.append(json.load(fh))
    return schemas


def _enum_union(values: list[Any], formatter: callable[[Any], str]) -> str:
    return " | ".join(formatter(value) for value in values)


def ts_type(prop: dict[str, Any]) -> str:
    if "enum" in prop:
        return _enum_union(prop["enum"], lambda value: json.dumps(value))

    ref = prop.get("$ref")
    if isinstance(ref, str):
        schema_type = prop.get("type")
        if isinstance(schema_type, list) and "null" in schema_type:
            return f"{ref} | null"
        return ref

    schema_type = prop.get("type")

    if isinstance(schema_type, list):
        includes_null = "null" in schema_type
        sub_types = [
            ts_type({**prop, "type": subtype}) for subtype in schema_type if subtype != "null"
        ]
        base = " | ".join(filter(None, sub_types)) or "unknown"
        return f"{base} | null" if includes_null else base

    if schema_type == "array":
        item_type = ts_type(prop.get("items", {}))
        return f"Array<{item_type}>"

    if schema_type == "object":
        properties = prop.get("properties")
        if isinstance(properties, dict) and properties:
            required = set(prop.get("required", []))
            members = []
            for key, value in properties.items():
                optional = "?" if key not in required else ""
                members.append(f"{key}{optional}: {ts_type(value)}")
            members_str = "; ".join(members)
            return f"{{ {members_str} }}"

        additional = prop.get("additionalProperties", True)
        if additional is False:
            return "Record<string, never>"
        if isinstance(additional, dict):
            value_type = ts_type(additional)
            return f"Record<string, {value_type}>"
        return "Record<string, unknown>"

    if isinstance(schema_type, str):
        return TS_PRIMITIVES.get(schema_type, "unknown")

    if "anyOf" in prop:
        return _enum_union(prop["anyOf"], ts_type)  # type: ignore[arg-type]

    if "oneOf" in prop:
        return _enum_union(prop["oneOf"], ts_type)  # type: ignore[arg-type]

    return "unknown"


def _format_literal(value: Any) -> str:
    if isinstance(value, str):
        return json.dumps(value)
    if value is None:
        return "None"
    return repr(value)


def py_type(
    prop: dict[str, Any],
    schema_name: str,
    nested_defs: dict[str, dict[str, Any]],
    path: list[str],
) -> str:
    if "enum" in prop:
        return f"Literal[{', '.join(_format_literal(value) for value in prop['enum'])}]"

    schema_type = prop.get("type")

    ref = prop.get("$ref")
    if isinstance(ref, str):
        py_ref = f"{ref}TypedDict"
        includes_null = False
        if isinstance(schema_type, list):
            includes_null = "null" in schema_type
        elif schema_type == "null":
            includes_null = True
        return f"{py_ref} | None" if includes_null else py_ref

    if isinstance(schema_type, list):
        includes_null = "null" in schema_type
        sub_types = [
            py_type({**prop, "type": subtype}, schema_name, nested_defs, path)
            for subtype in schema_type
            if subtype != "null"
        ]
        base = " | ".join(filter(None, sub_types)) or "Any"
        return f"{base} | None" if includes_null else base

    if schema_type == "array":
        item_type = py_type(prop.get("items", {}), schema_name, nested_defs, path + ["item"])
        return f"list[{item_type}]"

    if schema_type == "object":
        properties = prop.get("properties")
        if isinstance(properties, dict) and properties:
            class_name = _nested_typeddict_name(schema_name, path)
            if class_name not in nested_defs:
                nested_defs[class_name] = {
                    "schema_name": schema_name,
                    "prop": prop,
                    "path": path,
                }
            return class_name

        additional = prop.get("additionalProperties", True)
        if additional is False:
            return "dict[str, Any]"
        if isinstance(additional, dict):
            value_type = py_type(additional, schema_name, nested_defs, path + ["value"])
            return f"dict[str, {value_type}]"
        return "dict[str, Any]"

    if isinstance(schema_type, str):
        return PY_PRIMITIVES.get(schema_type, "Any")

    if "anyOf" in prop:
        return " | ".join(
            py_type(option, schema_name, nested_defs, path) for option in prop["anyOf"]
        )  # type: ignore[arg-type]

    if "oneOf" in prop:
        return " | ".join(
            py_type(option, schema_name, nested_defs, path) for option in prop["oneOf"]
        )  # type: ignore[arg-type]

    return "Any"


def generate_ts_interface(schema: dict[str, Any]) -> str:
    lines: list[str] = [f"export interface {schema['name']} {{"]
    required = set(schema.get("required", []))
    for key, prop in schema.get("properties", {}).items():
        optional = "?" if key not in required else ""
        type_annotation = ts_type(prop)
        lines.append(f"  {key}{optional}: {type_annotation};")
    lines.append("}")
    return "\n".join(lines)


def _render_typeddict_body(
    class_name: str,
    schema_name: str,
    prop_schema: dict[str, Any],
    nested_defs: dict[str, dict[str, Any]],
    base_path: list[str],
) -> list[str]:
    lines: list[str] = [f"class {class_name}(TypedDict, total=False):"]

    description = prop_schema.get("description")
    if description:
        lines.append(f'    """{description}"""')
        lines.append("")

    properties: dict[str, Any] = prop_schema.get("properties", {})
    if not properties:
        lines.append("    pass")
        return lines

    required = set(prop_schema.get("required", []))
    for key, value in properties.items():
        type_hint = py_type(value, schema_name, nested_defs, base_path + [key])
        if key in required:
            lines.append(f"    {key}: Required[{type_hint}]")
        else:
            lines.append(f"    {key}: NotRequired[{type_hint}]")

    return lines


def generate_py_typeddict(schema: dict[str, Any]) -> str:
    class_name = f"{schema['name']}TypedDict"
    nested_defs: dict[str, dict[str, Any]] = {}

    lines = _render_typeddict_body(class_name, schema["name"], schema, nested_defs, [])

    nested_outputs: list[str] = []
    processed: set[str] = set()

    while True:
        pending = [(name, data) for name, data in nested_defs.items() if name not in processed]
        if not pending:
            break

        pending.sort(key=lambda item: len(item[1]["path"]))
        name, data = pending[0]
        nested_lines = _render_typeddict_body(
            name,
            data["schema_name"],
            data["prop"],
            nested_defs,
            data["path"],
        )
        nested_outputs.append("\n".join(nested_lines))
        processed.add(name)

    body_sections = nested_outputs + ["\n".join(lines)]
    separator = "\n\n\n"
    return separator.join(section for section in body_sections if section)


def build_outputs(schemas: list[dict[str, Any]]) -> tuple[str, str]:
    if not schemas:
        raise ValueError("No schemas provided to build shared types")

    ts_lines: list[str] = [TS_HEADER.strip("\n"), ""]
    for schema in schemas:
        description = schema.get("description")
        if description:
            ts_lines.append(f"/** {description} */")
        ts_lines.append(generate_ts_interface(schema))
        ts_lines.append("")
    ts_output = "\n".join(ts_lines).rstrip() + "\n"

    typeddicts: list[str] = []
    for schema in schemas:
        typeddicts.append(generate_py_typeddict(schema))
        typeddicts.append("")
        typeddicts.append("")
    typeddict_body = "\n".join(typeddicts).rstrip()

    imports = {"TypedDict", "NotRequired", "Required"}
    if "Literal[" in typeddict_body:
        imports.add("Literal")

    if re.search(r"\bAny\b", typeddict_body):
        imports.add("Any")

    import_items = ", ".join(sorted(imports))
    import_line = f"from typing import {import_items}"

    py_lines: list[str] = [
        PY_HEADER.strip("\n"),
        "",
        "from __future__ import annotations",
        "",
        import_line,
        "",
        "",
        typeddict_body,
    ]
    py_output = "\n".join(py_lines).rstrip() + "\n"

    return ts_output, py_output


def main() -> None:
    schemas = load_schemas()
    if not schemas:
        raise SystemExit("No schemas found in shared/schema")

    ts_output, py_output = build_outputs(schemas)

    TS_TARGET.parent.mkdir(parents=True, exist_ok=True)
    TS_TARGET.write_text(ts_output, encoding="utf-8")

    PY_TARGET.write_text(py_output, encoding="utf-8")


if __name__ == "__main__":
    main()
