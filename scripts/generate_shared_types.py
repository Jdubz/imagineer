#!/usr/bin/env python3
"""Generate shared type definitions for frontend (TypeScript) and backend (Python)."""

from __future__ import annotations

import json
from pathlib import Path
from typing import Any

ROOT = Path(__file__).resolve().parent.parent
SCHEMA_DIR = ROOT / "shared" / "schema"
TS_TARGET = ROOT / "web" / "src" / "types" / "shared.ts"
PY_TARGET = ROOT / "server" / "shared_types.py"

TS_HEADER = """/* eslint-disable */
// AUTO-GENERATED BY scripts/generate_shared_types.py
// Do not edit this file manually.
"""

PY_HEADER = """\"\"\"AUTO-GENERATED FILE. DO NOT EDIT.

Generated by scripts/generate_shared_types.py
\"\"\"
"""


TS_PRIMITIVES: dict[str, str] = {
    "string": "string",
    "boolean": "boolean",
    "number": "number",
    "integer": "number",
    "null": "null",
}

PY_PRIMITIVES: dict[str, str] = {
    "string": "str",
    "boolean": "bool",
    "number": "float",
    "integer": "int",
    "null": "None",
}


def load_schemas() -> list[dict[str, Any]]:
    schemas: list[dict[str, Any]] = []
    if not SCHEMA_DIR.exists():
        return schemas
    for path in sorted(SCHEMA_DIR.glob("*.json")):
        with path.open("r", encoding="utf-8") as fh:
            schemas.append(json.load(fh))
    return schemas


def _enum_union(values: list[Any], formatter: callable[[Any], str]) -> str:
    return " | ".join(formatter(value) for value in values)


def ts_type(prop: dict[str, Any]) -> str:
    if "enum" in prop:
        return _enum_union(prop["enum"], lambda value: json.dumps(value))

    schema_type = prop.get("type")

    if isinstance(schema_type, list):
        includes_null = "null" in schema_type
        sub_types = [
            ts_type({**prop, "type": subtype}) for subtype in schema_type if subtype != "null"
        ]
        base = " | ".join(filter(None, sub_types)) or "unknown"
        return f"{base} | null" if includes_null else base

    if schema_type == "array":
        item_type = ts_type(prop.get("items", {}))
        return f"Array<{item_type}>"

    if schema_type == "object":
        return "Record<string, unknown>"

    if isinstance(schema_type, str):
        return TS_PRIMITIVES.get(schema_type, "unknown")

    if "anyOf" in prop:
        return _enum_union(prop["anyOf"], ts_type)  # type: ignore[arg-type]

    if "oneOf" in prop:
        return _enum_union(prop["oneOf"], ts_type)  # type: ignore[arg-type]

    return "unknown"


def _format_literal(value: Any) -> str:
    if isinstance(value, str):
        return repr(value)
    if value is None:
        return "None"
    return repr(value)


def py_type(prop: dict[str, Any]) -> str:
    if "enum" in prop:
        return f"Literal[{', '.join(_format_literal(value) for value in prop['enum'])}]"

    schema_type = prop.get("type")

    if isinstance(schema_type, list):
        includes_null = "null" in schema_type
        sub_types = [
            py_type({**prop, "type": subtype}) for subtype in schema_type if subtype != "null"
        ]
        base = " | ".join(filter(None, sub_types)) or "Any"
        return f"{base} | None" if includes_null else base

    if schema_type == "array":
        item_type = py_type(prop.get("items", {}))
        return f"list[{item_type}]"

    if schema_type == "object":
        return "dict[str, Any]"

    if isinstance(schema_type, str):
        return PY_PRIMITIVES.get(schema_type, "Any")

    if "anyOf" in prop:
        return " | ".join(py_type(option) for option in prop["anyOf"])  # type: ignore[arg-type]

    if "oneOf" in prop:
        return " | ".join(py_type(option) for option in prop["oneOf"])  # type: ignore[arg-type]

    return "Any"


def generate_ts_interface(schema: dict[str, Any]) -> str:
    lines: list[str] = [f"export interface {schema['name']} {{"]
    required = set(schema.get("required", []))
    for key, prop in schema.get("properties", {}).items():
        optional = "?" if key not in required else ""
        type_annotation = ts_type(prop)
        lines.append(f"  {key}{optional}: {type_annotation};")
    lines.append("}")
    return "\n".join(lines)


def generate_py_typeddict(schema: dict[str, Any]) -> str:
    class_name = f"{schema['name']}TypedDict"
    lines: list[str] = [f"class {class_name}(TypedDict, total=False):"]

    description = schema.get("description")
    if description:
        lines.append(f'    """{description}"""')
        lines.append("")

    properties: dict[str, Any] = schema.get("properties", {})
    if not properties:
        lines.append("    pass")
        return "\n".join(lines)

    required = set(schema.get("required", []))
    for key, prop in properties.items():
        type_hint = py_type(prop)
        if key in required:
            lines.append(f"    {key}: Required[{type_hint}]")
        else:
            lines.append(f"    {key}: NotRequired[{type_hint}]")

    return "\n".join(lines)


def main() -> None:
    schemas = load_schemas()
    if not schemas:
        raise SystemExit("No schemas found in shared/schema")

    # Generate TypeScript definitions
    ts_lines: list[str] = [TS_HEADER.strip("\n"), ""]
    for schema in schemas:
        description = schema.get("description")
        if description:
            ts_lines.append(f"/** {description} */")
        ts_lines.append(generate_ts_interface(schema))
        ts_lines.append("")
    ts_output = "\n".join(ts_lines).rstrip() + "\n"
    TS_TARGET.parent.mkdir(parents=True, exist_ok=True)
    TS_TARGET.write_text(ts_output, encoding="utf-8")

    # Generate Python TypedDicts
    typeddicts: list[str] = []
    for schema in schemas:
        typeddicts.append(generate_py_typeddict(schema))
        typeddicts.append("")
    typeddict_body = "\n".join(typeddicts).rstrip()

    imports = {"TypedDict", "NotRequired", "Required"}
    if "Literal[" in typeddict_body:
        imports.add("Literal")
    if "Any" in typeddict_body:
        imports.add("Any")

    import_items = ", ".join(sorted(imports))
    import_line = f"from typing import {import_items}"

    py_lines: list[str] = [
        PY_HEADER.strip("\n"),
        "",
        "from __future__ import annotations",
        "",
        import_line,
        "",
        "",
        typeddict_body,
    ]
    py_output = "\n".join(py_lines).rstrip() + "\n"
    PY_TARGET.write_text(py_output, encoding="utf-8")


if __name__ == "__main__":
    main()
